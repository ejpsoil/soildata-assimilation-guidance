<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>A pythonic &amp; participatory metadata workflow – Soil data guidance</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../style/styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="https://ejpsoil.eu" class="navbar-brand navbar-brand-logo">
    <img src="https://ejpsoil.eu/fileadmin/projects/ejpsoil/EJP_Soil_logo_cmyk-h100.png" alt="EJPSoil website" class="navbar-logo">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../identification.html"> 
<span class="menu-text">Identification</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../etl.html"> 
<span class="menu-text">Harmonization</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../codelists.html"> 
<span class="menu-text">Code lists</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../metadata.html"> 
<span class="menu-text">Discovery</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../view.html"> 
<span class="menu-text">View</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../download.html"> 
<span class="menu-text">Download</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../QOS.html"> 
<span class="menu-text">QOS</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../utils/index.html"> 
<span class="menu-text">Utilities &amp; Cookbooks</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../glossary.html"> 
<span class="menu-text">Glossary</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#initial" id="toc-initial" class="nav-link active" data-scroll-target="#initial">Initial</a></li>
  <li><a href="#create-an-mcf" id="toc-create-an-mcf" class="nav-link" data-scroll-target="#create-an-mcf">Create an MCF</a></li>
  <li><a href="#mdme" id="toc-mdme" class="nav-link" data-scroll-target="#mdme">MDME</a></li>
  <li><a href="#generate-iso191392007" id="toc-generate-iso191392007" class="nav-link" data-scroll-target="#generate-iso191392007">Generate iso19139:2007</a></li>
  <li><a href="#import-existing-metadata" id="toc-import-existing-metadata" class="nav-link" data-scroll-target="#import-existing-metadata">Import existing metadata</a></li>
  <li><a href="#import-generated-metadata-to-a-searchable-catalogue" id="toc-import-generated-metadata-to-a-searchable-catalogue" class="nav-link" data-scroll-target="#import-generated-metadata-to-a-searchable-catalogue">Import generated metadata to a searchable catalogue</a></li>
  <li><a href="#pygeodatacrawler" id="toc-pygeodatacrawler" class="nav-link" data-scroll-target="#pygeodatacrawler">pyGeoDataCrawler</a></li>
  <li><a href="#automated-workflows" id="toc-automated-workflows" class="nav-link" data-scroll-target="#automated-workflows">Automated workflows</a></li>
  <li><a href="#evaluate-metadata-and-discovery-service" id="toc-evaluate-metadata-and-discovery-service" class="nav-link" data-scroll-target="#evaluate-metadata-and-discovery-service">Evaluate Metadata and Discovery Service</a></li>
  <li><a href="#access-the-service-from-qgis" id="toc-access-the-service-from-qgis" class="nav-link" data-scroll-target="#access-the-service-from-qgis">Access the service from QGIS</a></li>
  <li><a href="#read-more" id="toc-read-more" class="nav-link" data-scroll-target="#read-more">Read more</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/ejpsoil/soildata-assimilation-guidance/edit/main/docs/cookbook/pygeometa.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/ejpsoil/soildata-assimilation-guidance/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">A pythonic &amp; participatory metadata workflow</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>This recipe presents a participatory, integrated and standardised approach to metadata management. Each data file on a file system will be accompagnied by a minimal metadata file. Crawler scripts will pick up these metadata files and publish them as iso19139 (or alternative models) on a searchable catalogue. iso19139 is the metadata model currently <a href="https://inspire.ec.europa.eu/id/document/tg/metadata-iso19139">mandated by INSPIRE</a> and very common in the GeoSpatial domain. Other communities tend to use different standards, such as <a href="https://stacspec.org/en/about/stac-spec/">STAC</a> (Earth Observation), <a href="https://www.w3.org/TR/vocab-dcat-2/">DCAT</a> (Open Data), <a href="https://schema.datacite.org/">DataCite</a> (Academia), which can benefit from the metadata workflow etc.</p>
<p>The recipe introduces you to the participatory metadata workflow step by step.</p>
<section id="initial" class="level2">
<h2 class="anchored" data-anchor-id="initial">Initial</h2>
<p>The inital step assumes a folder of data files on a network drive, sharepoint or git repository. Datasets stored on a database will not be considered for now, but can follow a similar workflow.</p>
<p>For each data file in the folder we will create a <code>metadata control file</code> (MCF). <a href="https://geopython.github.io/pygeometa/reference/mcf/">MCF</a> is a metadata format from the <a href="https://geopython.github.io/pygeometa">pygeometa</a> community. It is a <a href="https://en.wikipedia.org/wiki/YAML">YAML</a> encoded subset of thr iso19139:2007 model. YAML is easy to read by humans and an optimal for content versioning (in git). The pygeometa library is able to export the metadata control file into various common metadata formats.</p>
<p>Consider to set up a virtual environment for the workshop:</p>
<pre><code>virtualenv pygeometa &amp;&amp; cd pygeometa &amp;&amp; . bin/activate</code></pre>
<p>Then install the pygeometa library.</p>
<pre><code>pip install pygeometa</code></pre>
</section>
<section id="create-an-mcf" class="level2">
<h2 class="anchored" data-anchor-id="create-an-mcf">Create an MCF</h2>
<p>A minimal example of MCF is (see also a <a href="https://github.com/geopython/pygeometa/blob/master/sample.yml">more extended version</a>):</p>
<pre><code>mcf:
    version: 1.0

metadata:
    identifier: 3f342f64-9348-11df-ba6a-0014c2c00eab
    language: en
    hierarchylevel: dataset
    datestamp: 2023-01-01

spatial:
    datatype: grid

identification:
    language: eng
    title: Soilgrids sample Dataset
    abstract: This is a sample dataset for the EJP Soil Dataset Assimilation Masterclass
    dates:
        creation: 2023-01-01
    keywords:
        default:
            keywords: ["sample"]
    topiccategory:
        - geoscientificInformation
    extents:
        spatial:
            - bbox: [2,50,4,52]
              crs: 4326
    fees: None
    accessconstraints: otherRestrictions
    rights: CC-BY

contact:
    pointOfContact: 
        organization: ISRIC - World Soil Information
        url: https://www.isric.org
        city: Wageningen
        country: The Netherlands
        email: info@isric.org

distribution:
    wms:
        url: https://maps.isric.org
        type: OGC:WMS
        rel: service
        name: soilgrids</code></pre>
<p>Copy the content above into a new text file and save it with the same name as the dataset, but with an extension <code>.yml</code>. Use an advanced text editor such as <a href="https://notepad-plus-plus.org">notepad++</a> or <a href="https://code.visualstudio.com">Visual studio code</a> to benefit from yaml syntax highlighting and yaml validation. Notice that parsing in for example pygeometa fails if yaml is incorrectly formatted.</p>
</section>
<section id="mdme" class="level2">
<h2 class="anchored" data-anchor-id="mdme">MDME</h2>
<p><a href="https://osgeo.github.io/mdme">Model Driven Metadata Editor</a> (MDME) is an online visual editor for mcf files. You can create or load an existing mcf file, populate relevant fields and save it locally.</p>
</section>
<section id="generate-iso191392007" class="level2">
<h2 class="anchored" data-anchor-id="generate-iso191392007">Generate iso19139:2007</h2>
<p>As soon as you have a folder of MCF’s, you can use <code>pygeometa generate</code> to convert them to iso19139:2007.</p>
<pre><code>pygeometa metadata generate path/to/file.yml --schema=iso19139 --output=some_file.xml</code></pre>
<p>Or for a folder of files, save the content below to a .sh (mac/linux) or .bat (windows) file and run it:</p>
<pre><code>FILES="/path/to/*.yml"
for f in $FILES
do
  echo "Processing $f file..."
  pygeometa metadata generate $f --schema=iso19139 --output=$f.xml
done</code></pre>
<p>Notice that you can also <a href="https://geopython.github.io/pygeometa/tutorial/#adding-a-metadata-schema-to-the-core">create your own schema</a> for the iso19139 generation. By using a customised template you’re able to include additional properties for example to have better INSPIRE complience.</p>
<pre><code>pygeometa metadata generate path/to/file.yml --schema_local=/path/to/my-schema --output=some_file.xml</code></pre>
</section>
<section id="import-existing-metadata" class="level2">
<h2 class="anchored" data-anchor-id="import-existing-metadata">Import existing metadata</h2>
<p>If a data file already has a metadata document (for example with a shapefile, if it contains a file with extension .shp.xml), you can try to convert it to MCF using pygeometa. pygeometa requires to indicate the metadata schema in advance.</p>
<p>For iso19139:2007 use:</p>
<pre><code>pygeometa metadata import path/to/file.xml --schema=iso19139</code></pre>
<p>For fgdc (typically used with shapefiles) use:</p>
<pre><code>pygeometa metadata import path/to/file.xml --schema=fgdc</code></pre>
</section>
<section id="import-generated-metadata-to-a-searchable-catalogue" class="level2">
<h2 class="anchored" data-anchor-id="import-generated-metadata-to-a-searchable-catalogue">Import generated metadata to a searchable catalogue</h2>
<p><a href="https://www.pycsw.org">pycsw</a> is a python based OGC reference implementation of <a href="https://www.ogc.org/standards/cat">Catalog Service for the Web</a> and an early adaptor of <a href="https://ogcapi.ogc.org/records/">OGC API Records</a> and <a href="https://stacspec.org/en">STAC Catalog</a>. We’ll use pycsw via a <a href="https://docs.pycsw.org/en/latest/docker.html">docker image</a> to publish the metadata records in a search service. We run it in <code>detach</code> mode so we can interact with the running container, type <code>docker stop pycsw</code> to stop the container.</p>
<pre><code>docker run -d --rm --name pycsw -p 8000:8000 geopython/pycsw</code></pre>
<p>We now have a running pycsw at http://localhost:8000/collections with some sample data. We will now remove the sample data and insert our metadata. For that reason we <code>mount</code> our current folder with xml files into the container</p>
<pre><code>docker stop pycsw
docker run -d --rm --name pycsw -v ${PWD}:/metadata -p 8000:8000 geopython/pycsw</code></pre>
<p>Now we can trigger pycsw admin to remove the default records and import our metadata. As part of the calls we reference the config file, which contains the connection details to the database.</p>
<pre><code>docker exec -ti pycsw pycsw-admin.py delete-records -c /etc/pycsw/pycsw.cfg
docker exec -ti pycsw pycsw-admin.py load-records -c /etc/pycsw/pycsw.cfg -p /metadata -r</code></pre>
<p>Check out the new content at http://localhost:8000/collections. Note that if you restart the container, all records are removed, because the database is currently not persisted on a volume.</p>
<p>Try to mount also a customised <a href="https://github.com/geopython/pycsw/blob/master/docker/pycsw.cfg">configuration file</a> into the container, so you can optimise the configuration of the catalogue. Also have a look at the <a href="https://docs.pycsw.org/en/latest/profiles.html#inspire-extension">INSPIRE extension</a> for pycsw.</p>
</section>
<section id="pygeodatacrawler" class="level2">
<h2 class="anchored" data-anchor-id="pygeodatacrawler">pyGeoDataCrawler</h2>
<p><a href="https://github.com/pvgenuchten/pyGeoDataCrawler">pyGeoDataCrawler</a> is a tool under active development which builds on top of the mechanism described above, internally using the libraries mentioned. It crawls a folder structure for metadata and data files, if no metadata file exists for a dataset, it will create one based on derived metadata from the dataset. Discovered metadata files are exported to iso19139 ready to be imported into a catalogue like pycsw or GeoNetwork.</p>
</section>
<section id="automated-workflows" class="level2">
<h2 class="anchored" data-anchor-id="automated-workflows">Automated workflows</h2>
<p>The tasks above are carried out manually. However they can also be set up to run automated at file changes or at regular intervals using cron jobs. With such an approach you can automatically update the catalogue content when for example some metadata records are updated or added to the GIT repository (CI-CD). To facilitate the participatory approach, consider to include a link from the dataset page in the catalogue back to the git source, to invite users to suggest optimizations to the metadata records (as GIT issue or Pull Request).</p>
</section>
<section id="evaluate-metadata-and-discovery-service" class="level2">
<h2 class="anchored" data-anchor-id="evaluate-metadata-and-discovery-service">Evaluate Metadata and Discovery Service</h2>
<p>You can evaluate individual iso19139 records in the <a href="https://inspire.ec.europa.eu/validator/home/index.html">INSPIRE reference validator</a>. The validator can also evaluate the discovery service itself. If a service is running on localhost, use the <a href="../utils/localtunnel.html">tunnel approach</a> to evaluate it. <a href="https://www.geohealthcheck.org">GeoHealthCheck</a> also includes a probe for testing availability of a <a href="https://demo.geohealthcheck.org/resources?lang=en&amp;resource_type=OGC%3ACSW">CSW service</a>.</p>
</section>
<section id="access-the-service-from-qgis" class="level2">
<h2 class="anchored" data-anchor-id="access-the-service-from-qgis">Access the service from QGIS</h2>
<p>QGIS contains a default plugin called <a href="https://docs.qgis.org/3.22/en/docs/user_manual/plugins/core_plugins/plugins_metasearch.html">MetaSearch</a> which enables catalogue searches from within QGIS. You can find the plugin in the <code>web</code> menu or on the toolbar as a set of binoculars. Open the plugin. First you need to set up a new service connection. On the services tab, click new, choose a name and add the url http://localhost:8080/csw. Click the <code>serviceinfo</code> button to view the metadata of the service. Now return to the <code>Search</code> tab and perform a search. Notice that if you select a search result, it highlights on the map and may trigger the <code>Add data</code> button in the footer (this depends on if QGIS recognises the protocol mentioned in the metadata).</p>
</section>
<section id="read-more" class="level2">
<h2 class="anchored" data-anchor-id="read-more">Read more</h2>
<p>At masterclass edition 2023 Tom Kralidis presented the geopython ecosystem, including pycsw.</p>
<iframe title="Embedded Media titled: geopython" width="560" height="315" src="https://wur.yuja.com/V/Video?v=432913&amp;node=1952041&amp;a=194733222&amp;preload=false" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen="" loading="lazy">
</iframe>
<ul>
<li><a href="https://github.com/geopython">github</a> the geopython community welcomes your questions and contributions.</li>
<li><a href="https://geopython.github.io/pygeometa">pygeometa</a></li>
<li><a href="https://pycsw.org">pycsw</a></li>
<li><a href="https://github.com/pvgenuchten/pyGeoDataCrawler">pyGeoDataCrawler</a> is a set of scripts to manage MCF’s. It supports importing MCF from a CSV, MCF inheritence, generate MCF from a data file, etc.</li>
<li><a href="https://github.com/osgeo/mdme">Model Driven Metadata Editor</a> A web based GUI for populating MCF’s.</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/ejpsoil\.github\.io\/soildata-assimilation-guidance\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/ejpsoil/soildata-assimilation-guidance/edit/main/docs/cookbook/pygeometa.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/ejpsoil/soildata-assimilation-guidance/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../about.html">
<p>About</p>
</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="../license.html">
<p>License</p>
</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="https://cordis.europa.eu/project/id/862695">
<p><img style="width:80px;margin:5px 0px" src="https://ejpsoil.eu/fileadmin/_processed_/0/3/csm_Horizon_2020_funding_Thumbnail_a20cd538b7.jpg"></p>
</a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>